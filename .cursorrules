# Task Mail Project - MCP-Enhanced Development

## Project Overview

This is an email management system that integrates Apple Mail with AI-powered task automation. Built with Node.js/Express backend, React 18 + TypeScript frontend, Supabase PostgreSQL database, and GPT-5 AI services.

**Tech Stack:**
- Backend: Node.js, Express.js, Supabase (PostgreSQL)  
- Frontend: React 18, TypeScript, Zustand state management
- AI: GPT-5 mini/nano models for email classification and automation
- Integration: Apple Mail SQLite (read-only), AppleScript for draft sync
- Testing: Jest (backend), React Testing Library (frontend), Playwright (E2E)

**Architecture:**
- Single database (Supabase) as source of truth
- Read-only Apple Mail SQLite integration via EnhancedAppleMailSync
- Bidirectional draft sync using AppleScript (Mac-only)
- AI-powered email classification, task generation, and automation rules

## Core Development Rules

### Code Quality Standards
- Always complete implementations fully - no TODO comments or stub functions
- Evidence-based development - all assertions must be testable/verifiable
- Follow existing project patterns and maintain consistency
- Run lint/typecheck before considering any task complete

### File Organization
- Tests: Place in `tests/`, `__tests__/`, or `test/` directories only
- Scripts: Use `scripts/`, `tools/`, or `bin/` directories
- Documentation: Use `docs/` or project root for main documentation
- Never scatter test files or utility scripts throughout the codebase

### Git Workflow
- Always check `git status && git branch` before starting work
- Create feature branches for ALL work - never work directly on main
- Use PM2 for process management (not manual node commands or & background processes)
- Commit frequently with descriptive, conventional commit messages
- Verify changes with `git diff` before staging

## MCP Server Usage Guidelines

Choose the optimal MCP server based on task requirements:

**Sequential MCP** → Complex analysis (3+ components), debugging, architecture decisions, systematic problem solving
**Serena MCP** → Symbol operations, project memory, large codebase navigation (>50 files), session persistence
**Morphllm MCP** → Pattern-based edits, bulk transformations, style enforcement (<10 files), token efficiency
**Playwright MCP** → Browser testing, E2E scenarios, visual validation, accessibility testing
**Context7 MCP** → Official documentation, framework patterns, library APIs, version-specific requirements
**Native Claude** → Simple explanations, basic fixes, single-file changes

### Multi-Server Workflows
1. **Analysis → Implementation**: Sequential plans strategy → Morphllm executes bulk edits
2. **Research → Validation**: Context7 supplies patterns → Playwright validates behavior
3. **Design → Build**: Sequential coordinates analysis → Context7 provides official patterns

## Implementation Standards

### Critical Requirements (Never Compromise)
- Build ONLY what's requested - no scope creep or speculative features
- Complete all features to working state - no partial implementations
- Use absolute file paths for all file operations
- Never auto-commit changes - allow user review first
- Always investigate root causes of failures - don't skip validation steps

### Quality Assurance
- Follow SOLID principles and DRY/KISS/YAGNI patterns
- Use descriptive naming conventions consistent with existing code
- Maintain clean workspace - remove temporary files after use
- Professional communication - avoid marketing language or unverifiable metrics

### Efficiency Patterns
- Batch operations: use MultiEdit for multiple file changes
- Parallel execution: run independent operations concurrently
- Tool optimization: choose most powerful tool for each task type
- Memory management: use Serena for cross-session project context

## Task Mail Specific Guidelines

### Email Processing
- All Apple Mail data is READ-ONLY via SQLite integration
- Email modifications must go through Supabase database
- Draft sync uses AppleScript automation (Mac-only)
- GPT-5 mini/nano preferred for AI operations (check .env configuration)

### Service Architecture  
- Use OptimizedDatabaseAgent for ALL Supabase operations
- Follow enhanced services pattern: EnhancedAppleMailSync, GPTService, AutomationEngine, DraftSyncService
- All API routes must validate inputs and return proper JSON with status codes
- Use PM2 for process management - never use manual node server.js or background processes
- WebSocket for real-time updates, REST for standard operations

### Frontend Development
- Follow Zustand store patterns: emailStore, taskStore, aiStore, automationStore
- Maintain accessibility standards for email interface components
- Use TypeScript strictly - no `any` types without justification
- Connect to backend via established API service endpoints

### Testing Strategy
- Backend: Jest with supertest for API testing
- Frontend: React Testing Library for component testing  
- Database: Integration tests for Supabase operations
- E2E: Playwright for email workflow testing
- AI Features: Integration tests for GPT service and automation rules

## Workflow Patterns

### For Complex Tasks (>3 steps)
1. Use TodoWrite to plan and track progress
2. Break down into phases: Analysis → Implementation → Testing → Validation
3. Update todos as completed, maintain one active task at a time
4. Use appropriate MCP tools for each phase

### For Multi-File Operations
1. Sequential MCP: Plan strategy and identify dependencies
2. Serena MCP: Analyze semantic relationships and symbol usage
3. Morphllm MCP: Execute pattern-based transformations
4. Validate: Run tests and quality checks

### For New Features
1. Context7 MCP: Research official patterns and best practices
2. Plan implementation following existing architecture
3. Implement incrementally with frequent testing
4. Playwright MCP: Create E2E tests for user workflows

## Error Handling

- Always investigate WHY errors occur, not just THAT they occurred
- Never disable or skip tests to make builds pass
- Debug systematically: read error messages → identify root cause → fix properly
- For tool failures: investigate before switching approaches
- Maintain system integrity over quick fixes

## Logging and Documentation

- Include appropriate logging statements in all new code
- Generate unit tests for non-trivial functionality
- Add docstrings and inline comments for complex logic
- Update README sections when adding new features
- Document architectural decisions and API changes

## Performance and Scalability

- Optimize for maintainability first, then performance
- Use async/await patterns for I/O operations
- Implement proper error boundaries and graceful degradation
- Monitor resource usage and implement caching where appropriate
- Consider token limits when working with AI services